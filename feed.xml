<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://yolken.net/feed.xml" rel="self" type="application/atom+xml" /><link href="https://yolken.net/" rel="alternate" type="text/html" /><updated>2019-09-01T18:02:57-07:00</updated><id>https://yolken.net/feed.xml</id><title type="html">Benjamin Yolken</title><subtitle>Random thoughts from the perspective of a software engineer, particularly around tech careers and development processes.</subtitle><entry><title type="html">Interviewing with Triplebyte</title><link href="https://yolken.net/blog/triplebyte-review" rel="alternate" type="text/html" title="Interviewing with Triplebyte" /><published>2019-08-31T16:23:00-07:00</published><updated>2019-08-31T16:23:00-07:00</updated><id>https://yolken.net/blog/triplebyte-review</id><content type="html" xml:base="https://yolken.net/blog/triplebyte-review">&lt;p&gt;In my most recent job search, I used a service called
&lt;a href=&quot;https://triplebyte.com/&quot;&gt;Triplebyte&lt;/a&gt; to connect with potential employers.
Triplebyte basically plays the role of a third-party recruiter- it signs
solicitation agreements with clients (i.e., companies) and then matches
candidates with open jobs at these companies. If a candidate brought in by the
recruiter ends up signing an offer with a client, the client pays a certain
percentage of the the candidate’s first year salary as a fee.&lt;/p&gt;

&lt;p&gt;Unlike traditional third-party recruiters, who usually just pass you off
to their clients’ own recruiters, Triplebyte actually does some of the
technical screening itself. It also uses technology (i.e., a slick web site)
to handle the logistics around sending messages back and forth,
scheduling calls, collecting feedback, etc.&lt;/p&gt;

&lt;p&gt;In the end, I decided to accept a job that I found through a non-Triplebyte
source. However, I had an interesting experience with Triplebyte, and
I wanted to share my thoughts in case others are considering using their
services.&lt;/p&gt;

&lt;h2 id=&quot;how-triplebyte-works&quot;&gt;How Triplebyte works&lt;/h2&gt;

&lt;p&gt;First, you do a short, online, multiple-choice test that covers coding, SQL,
computer hardware, and a few other, related topics.&lt;/p&gt;

&lt;p&gt;If you pass the online test, then you can schedule a two hour video chat with a
Triplebyte interviewer. This chat is like a traditional, technical phone screen,
except longer- it covers writing code, debugging an existing codebase, systems
design, and basic technical knowledge (e.g., how HTTP works).&lt;/p&gt;

&lt;p&gt;If you pass the video interview, then you move to the matching phase. The
Triplebyte site shows you a list of companies matching your criteria; you can
select which you’re particularly interested in and (optionally) write them
messages explaining why. You also fill out a calendar to specify when you’re
available for “pitch” calls.&lt;/p&gt;

&lt;p&gt;After a few days, your profile goes “live” allowing companies to see it. If
you’ve already expressed interest in a company, and they’re also interested
in you, they’re allowed to put a call in your calendar without asking. If they’re
interested in you but you didn’t explicitly express interest in them, they can
still write you a message asking for a chance to chat; if you accept,
then they’re also allowed to put time in your calendar.&lt;/p&gt;

&lt;p&gt;You then do a 30-45 minute call with each company that you’ve matched with.
These calls are mostly for the companies to sell themselves to you. They can
also ask you questions about your background and interests, although, per
Triplebyte policy, they’re not allowed to ask any technical questions at this
stage.&lt;/p&gt;

&lt;p&gt;After each call, both you and the company indicate whether you want to move
forward. If there’s still a match, you work with the company to schedule
an on-site, and from this point forward you follow the standard, non-Triplebyte
process.&lt;/p&gt;

&lt;p&gt;In the end, if you accept an offer from one of the companies you matched
with, the company pays Triplebyte according to their agreement. Triplebyte
doesn’t disclose its fees publicly, but third-party recruiters typically
charge at least 25% of the candidate’s first year salary.&lt;/p&gt;

&lt;h2 id=&quot;the-stats&quot;&gt;The stats&lt;/h2&gt;

&lt;p&gt;After making it through the multiple-choice screen and video interview, I was shown
around 50 companies that met my criteria (in San Francisco, 100+ employees).
Around 20 expressed interest in me, and I did pitch calls with 8 of them. 7 of
these invited me on-site, I did 2 on-sites, and, in the end, I got 2 offers.&lt;/p&gt;

&lt;h2 id=&quot;the-good&quot;&gt;The good&lt;/h2&gt;

&lt;h4 id=&quot;saving-time&quot;&gt;Saving time&lt;/h4&gt;

&lt;p&gt;The marketing pitch for Triplebyte is that they save candidates time, and, at least
in my personal case, I found this to be true. It took a few hours for me
to set up my profile and do the initial screens, but it saved me much more
than that because I didn’t have to do recruiter and technical screens for
each of the companies I matched with.&lt;/p&gt;

&lt;p&gt;In addition to taking a lot of time, these per-company screens can be a pain to
schedule and usually can only be done during business hours. Triplebyte’s interview,
on the other hand, is scheduled by picking a slot from a list of options
on their site. Because many of their interviewers are remote and/or working part-time,
they have slots available almost 24/7. I did my interview 9:00-11:00PM on a Friday night
with a nice Polish guy, for whom it was Saturday morning.&lt;/p&gt;

&lt;p&gt;You still have to do “pitch” calls before going on-site, but I found these
pretty easy to fit into my schedule because they’re short and don’t have the usual
requirements of a technical interview (computer, quiet room, good Internet, etc.).&lt;/p&gt;

&lt;h4 id=&quot;detailed-feedback&quot;&gt;Detailed feedback&lt;/h4&gt;

&lt;p&gt;Triplebyte provided very detailed feedback for the two hour video
interview that they did with me. I didn’t learn too much from it that
I didn’t already know, but I can imagine that this feedback would be helpful
for people who haven’t had a lot of recent interview experience.&lt;/p&gt;

&lt;h4 id=&quot;low-pressure&quot;&gt;Low pressure&lt;/h4&gt;

&lt;p&gt;I’ve worked with several third-party recruiters in past job searches. They can be
extremely aggressive and needy, some to the point of wanting to chat every day
until I’ve finally signed an offer. I’m an introvert, and, moreover, when I’m
looking for a job I’m usually busier than usual, so I find this kind of
attention pretty annoying.&lt;/p&gt;

&lt;p&gt;Triplebyte’s staff, on the other hand, were super laid back. I spoke to my “talent
manager” (i.e., recruiter) once on the phone and then maybe twice over
email over the following weeks. Aside from a few automated emails asking for
feedback, I didn’t feel that any of their communication was superfluous.&lt;/p&gt;

&lt;h2 id=&quot;the-bad&quot;&gt;The bad&lt;/h2&gt;

&lt;h4 id=&quot;limited-matches&quot;&gt;Limited matches&lt;/h4&gt;

&lt;p&gt;The 5 or so client companies that I was most interested in chose not to match
with me. This was their right, of course, but it was a little frustrating, and
it’s an aspect of the process that Triplebyte’s marketing glosses over.&lt;/p&gt;

&lt;p&gt;In the end, I matched with some interesting companies lower down on my list, so I
still felt that Triplebyte was worth it. However, I’ve heard anecdotally that some
candidates have trouble matching with any companies that they’re even remotely
interested in; this may be more likely if your profile is a little riskier for
potential employers, i.e. you’re not already local or you don’t have well-known companies
on your resume.&lt;/p&gt;

&lt;h4 id=&quot;trivia-questions-in-interviews&quot;&gt;Trivia questions in interviews&lt;/h4&gt;

&lt;p&gt;The video interview was a little less practical than I ideally would have liked;
a decent chunk of it consisted of what I would consider “trivia” questions
(see &lt;a href=&quot;/blog/rules-for-better-interviews&quot;&gt;this previous post&lt;/a&gt; for my thoughts on these
types of questions). In Triplebyte’s defense, though, I would imagine that many
of their clients also ask these types of questions, so they need to include them
in their assessment.&lt;/p&gt;

&lt;h4 id=&quot;rushed-process&quot;&gt;Rushed process&lt;/h4&gt;

&lt;p&gt;Triplebyte’s process is designed to be fast; your profile is only “live” for a week,
and, because you skip the technical screens, you have to make a decision about whether
to go on-site quickly and with less information than you’d typically have at this stage in the
process. This is great for people who have lots of free time (e.g., because they’re not currently
working) and want to do lots of on-sites, but for people like me who are already working
and want to be more deliberate, it can make it hard to know whether a role is a good match.&lt;/p&gt;

&lt;p&gt;One thing I did with one of the companies I matched with but was feeling on-the-fence about was to
arrange an office visit and casual lunch with the hiring manager after the pitch call. This helped
me to decide that the role wasn’t the best fit, which saved both me and the company a lot of time.
It would be nice if Triplebyte facilitated these kind of pre-on-site, casual meetings for
local candidates who can’t spend two weeks doing on-sites.&lt;/p&gt;

&lt;h2 id=&quot;the-verdict&quot;&gt;The verdict&lt;/h2&gt;

&lt;p&gt;Overall, I would recommend Triplebyte to people seeking software engineering jobs
in the Bay Area. It doesn’t require a huge amount of time and effort, and the downsides
are pretty limited; even if you don’t pass their process, you’ll get some practice (with detailed
feedback), and you can still apply to their client companies directly.&lt;/p&gt;</content><author><name></name></author><summary type="html">In my most recent job search, I used a service called Triplebyte to connect with potential employers. I wanted to share my thoughts in case others are considering using their services to find a job.</summary></entry><entry><title type="html">The rules for better coding interviews</title><link href="https://yolken.net/blog/rules-for-better-interviews" rel="alternate" type="text/html" title="The rules for better coding interviews" /><published>2019-06-09T16:49:00-07:00</published><updated>2019-06-09T16:49:00-07:00</updated><id>https://yolken.net/blog/rules-for-better-interviews</id><content type="html" xml:base="https://yolken.net/blog/rules-for-better-interviews">&lt;p&gt;In a &lt;a href=&quot;/blog/master-coding-interviews&quot;&gt;previous post&lt;/a&gt;, I discussed preparing for coding
interviews as a candidate. In this post, I want to flip to the other side of the table
and talk about conducting better interviews from the interviewer perspective.&lt;/p&gt;

&lt;h2 id=&quot;goals-of-an-interview&quot;&gt;Goals of an interview&lt;/h2&gt;

&lt;p&gt;Before digging into the details, it’s worth reviewing what the purpose of an interview is-
figuring out whether a random person who you probably don’t know much about (i.e., “the candidate”)
is a good match for a specific position at your company (i.e., “the job”).&lt;/p&gt;

&lt;p&gt;The most reliable way to figure out whether the candidate is a match for the job is to
observe them doing the job or, at least, doing activities that are as close as possible to the
work involved in the job. If you were interviewing a chef for a restaurant, you would ask
them to cook a meal for you. Likewise, in the case of a software engineer, your interview should
focus on things that software engineers actually do day-to-day- writing, testing, and running code
on a computer, debugging issues in systems, and explaining technical ideas to colleagues, among
other things.&lt;/p&gt;

&lt;p&gt;Questions that are not directly related to day-to-day work on the job may have some correlation
with eventual job performance, but it’s not going to be as strong. Given the amount of time required
for the interview on both sides as well as the risk of bad hiring decisions, it’s best for all
questions to be as practical and job-relevant as possible.&lt;/p&gt;

&lt;h2 id=&quot;the-rules&quot;&gt;The rules&lt;/h2&gt;

&lt;p&gt;Now that we’ve covered the purpose of interviewing, I’d like to share some “rules” for coding
interviews to ensure that they’re productive and provide good signal.&lt;/p&gt;

&lt;h3 id=&quot;rule-1-coding-problems-should-be-done-on-a-computer-not-a-whiteboard&quot;&gt;Rule 1: Coding problems should be done on a computer, not a whiteboard&lt;/h3&gt;

&lt;p&gt;Writing code on a whiteboard made sense 25 years ago, before laptops were ubiquitous and
when compiling and testing small programs could be painful due to primitive tooling.
Now, there’s really no good reason to do it. Unless you happen to be at a company where software
is written without computers, having a candidate use a computer is much closer to the work in the
actual job and, therefore, is a more accurate way to predict job performance.&lt;/p&gt;

&lt;p&gt;Beyond the high-level, philosophical reasons for doing coding problems on computers, there are
a number of practical benefits for both the candidate and the interviewing company:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Writing code on a computer, ideally their own computer, allows the candidate to use the tooling
  that they feel comfortable with and that makes them productive. Since engineers at most
  companies are allowed to pick their own tooling (within reasonable limits), this better matches
  the conditions of the actual job.&lt;/li&gt;
  &lt;li&gt;On a computer, you can’t hand-wave away parts of your solution (e.g., “suppose we had a helper
  function that implemented a binary search”). The candidate has to either implement it themselves
  or find some existing code or library to use.&lt;/li&gt;
  &lt;li&gt;Coding problems on a computer requires the candidate to write tests and then iteratively
  debug problems that are found. These testing and debugging skills are an important part of
  software engineering work, but they’re much harder to evaluate on a whiteboard.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rule-2-please-no-algorithm-trivia&quot;&gt;Rule 2: Please, no algorithm trivia&lt;/h3&gt;

&lt;p&gt;Understanding algorithms and data structures is a prerequisite for writing good software. Having
them all committed to memory, however, is not. This is particularly true for the long tail things
that are rarely encountered in day-to-day work. Quizzing a candidate on lexicographic sorting, heap
implementations, or reversing linked lists is usually just a waste of time- if you need to
understand the details of these things on the job, you can just look them up.&lt;/p&gt;

&lt;p&gt;The same goes for trivia about programming language syntax, operating systems, hardware,
or other technical topics. If it’s something that people can either pick up on the job or look up
as needed, you’re not actually measuring something that’s critical for job success; instead,
you’re picking up correlated skills (e.g., studying and memorization) that may not be relevant.&lt;/p&gt;

&lt;h3 id=&quot;rule-3-avoid-one-shot-all-or-nothing-problems&quot;&gt;Rule 3: Avoid one-shot, all or nothing problems&lt;/h3&gt;

&lt;p&gt;Most problems that engineers work on are done in stages. You usually don’t deliver a new system in
a single commit. Instead, you start with the high-level data models and interfaces, sketch out
the key classes, fill in the blanks with basic implementations, then come back and optimize
as needed. At each stage, you get feedback from your peers (or, in some cases, your end users), and
make course corrections as needed before continuing to the next stage.&lt;/p&gt;

&lt;p&gt;Coding problems done in interviews should ideally be structured in a similar way. Instead of
just throwing a problem out and asking the candidate to solve it end-to-end in one burst, it’s
better to divide it into chunks and work through it in stages- first, have the candidate write
a skeleton class, then ask them to add in a method to do X, then a method to do Y that uses X, etc.
Ideally, there should be a long list of these extensions so that even the best candidates never
make it through all of them.&lt;/p&gt;

&lt;p&gt;In addition to being more like real projects, this approach has a number of other,
interview-specific benefits:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Candidates are eased into the problem gradually. If they’re prone to interview anxiety
  (as I often am), this makes them feel more comfortable.&lt;/li&gt;
  &lt;li&gt;Having seen the problem before is less of an advantage. The candidate may be able to get
  an answer to the core parts very quickly, but then you can just ask harder and harder extensions
  which they’re less likely to have prepared solutions for.&lt;/li&gt;
  &lt;li&gt;Performance is less likely to be binary. Even weak candidates should make some progress,
  whereas stronger candidates will get to different parts of the problem depending on their
  skills and background. This allows for more granular feedback than simply “they got the problem
  so they passed” or “they didn’t get it so they failed”.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;other-approaches-to-more-practical-interviews&quot;&gt;Other approaches to more practical interviews&lt;/h2&gt;

&lt;p&gt;Over the course of my career, I’ve seen companies take other approaches to make their
interviews better match real work. These are less common and a bit more controversial than
the rules above, so I’m putting them in their own section.&lt;/p&gt;

&lt;h3 id=&quot;mini-projects&quot;&gt;Mini-projects&lt;/h3&gt;

&lt;p&gt;Instead of asking a bunch of smaller, 45-60 minute technical questions, some companies have their
candidates do a single “mini-project”. The work is either done at home, before the interview,
or for a couple of hours on site. Ideally, the candidate doesn’t just submit their code but also
gets a chance to present their work and discuss why they took the approaches that they did with
their interviewers.&lt;/p&gt;

&lt;p&gt;I think these projects can be a good way to make interviews more realistic and give candidates
a chance to show off their skills. On the other hand, when the project is done at home (as is
usually the case), there’s pressure to spend a lot of time on it, way more than the suggested
amount, to make a good impression. This can be unfair for candidates who have full-time jobs
and/or significant personal obligations outside of work.&lt;/p&gt;

&lt;h3 id=&quot;pairing&quot;&gt;Pairing&lt;/h3&gt;

&lt;p&gt;The idea here is to have the candidate pair with a member of the team instead of solving interview
problems by themselves. The pair can work together on either made-up interview questions or,
in some cases, actual project work for the company. Ideally, the company has hardware set up
that’s designed for pairing, i.e. two monitors, mice, and keyboards connected to a single computer.&lt;/p&gt;

&lt;p&gt;The advantages over standard, non-paired interviews are that:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The interview better tests collaboration, a big part of practical software work, by forcing the
  candidate to work directly with someone else.&lt;/li&gt;
  &lt;li&gt;The interviewer can step in and help the candidate make progress when they get stuck.&lt;/li&gt;
  &lt;li&gt;If the pairing is on actual project work, the interview can be a more realistic test of how
  well the candidate will perform on the job.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think there are good intentions here. In practice, though, there are a number of issues I’ve
seen with pairing interviews that make me have mixed feeling about them:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If the company provides its own hardware, then the candidate might be forced to use a setup
  that’s not ideal for them.&lt;/li&gt;
  &lt;li&gt;Often, there really isn’t much pairing going on- the interviewer just watches the candidate solve
  the question like in a normal, non-paired interview.&lt;/li&gt;
  &lt;li&gt;If the pairing is on actual project work, then the candidate is basically being forced to do
  unpaid work. Aside from the potential legal issues involved here, this can feel
  exploitative.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;concluding-thoughts&quot;&gt;Concluding thoughts&lt;/h2&gt;

&lt;p&gt;Interviews should measure how well candidates do on realistic problems under job-like constraints.
Despite the common sense behind this, I still see companies routinely asking abstract, one-shot,
whiteboard coding questions. Just don’t do this- it’s not the way to hire the best people.&lt;/p&gt;</content><author><name></name></author><summary type="html">In a previous post, I discussed preparing for coding interviews as a candidate. In this post, I want to flip to the other side of the table and talk about conducting better interviews from the interviewer perspective.</summary></entry><entry><title type="html">Using Leetcode to master coding interviews</title><link href="https://yolken.net/blog/master-coding-interviews" rel="alternate" type="text/html" title="Using Leetcode to master coding interviews" /><published>2019-05-27T14:38:04-07:00</published><updated>2019-05-27T14:38:04-07:00</updated><id>https://yolken.net/blog/master-coding-interviews</id><content type="html" xml:base="https://yolken.net/blog/master-coding-interviews">&lt;p&gt;&lt;img src=&quot;/assets/leetcode.png&quot; alt=&quot;Leetcode image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Having switched jobs &lt;a href=&quot;https://www.linkedin.com/in/yolken/&quot;&gt;a few times&lt;/a&gt; over the last few years,
I’ve done a &lt;em&gt;a lot&lt;/em&gt; of software engineering interviews. In my most recent job search, for instance,
I did around eight phone screens followed by six on-sites.&lt;/p&gt;

&lt;p&gt;The most stressful part of any interview for me, and for many others as well,
is the “technical coding” questions that inevitably get asked; most companies require you to solve
at least one during a phone screen, and then another two to four once you get onsite.&lt;/p&gt;

&lt;p&gt;Over the last few job searches, I’ve developed a strategy that has significantly improved my
performance on these questions, to the point that I’m now rarely phased by them. In this post, I’d
like to share what I’ve learned.&lt;/p&gt;

&lt;h2 id=&quot;practice-practice-practice&quot;&gt;Practice, practice, practice&lt;/h2&gt;

&lt;p&gt;The key to doing an excellent job in a coding-oriented software interview is very simple- you
&lt;em&gt;really, really&lt;/em&gt; need to practice beforehand. The interesting thing about practice is that it’s
more effective, more necessary, and more profitable than one would intuitively think.&lt;/p&gt;

&lt;h3 id=&quot;why-its-more-effective-than-you-think&quot;&gt;Why it’s more effective than you think&lt;/h3&gt;

&lt;p&gt;Software is such a broad field and there are so many technologies and applications that could come
up in an interview! Sure, practice can help, but how can it really make that much of a difference?&lt;/p&gt;

&lt;p&gt;The reality, however, is that only a small subset of these are appropriate for an interview. In
particular, companies generally restrict their questions to those that:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Can be explained in under 5 minutes&lt;/li&gt;
  &lt;li&gt;Can be solved by a good candidate, starting from scratch, in under 30 minutes&lt;/li&gt;
  &lt;li&gt;Don’t require specialized, domain-specific knowledge
  (e.g., networking, databases, cryptography, graphical user interfaces, etc.)&lt;/li&gt;
  &lt;li&gt;Don’t require external data, documentation, hardware, or software libraries / code&lt;/li&gt;
  &lt;li&gt;Touch on intro-undergraduate-level algorithms and data structures including
  sorting, searching, dynamic programming, lists, hashmaps, etc.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These restrictions significantly reduce the pool of possible questions. Even if you
get a question that isn’t exactly like one you covered in your practice, chances are that it
has some similarities to one you have seen, and you can use those to your advantage.&lt;/p&gt;

&lt;h3 id=&quot;why-its-more-necessary-than-you-think&quot;&gt;Why it’s more necessary than you think&lt;/h3&gt;

&lt;p&gt;Another misconception is that if you’re already doing a lot of hands-on software development
as part of your day-to-day job, this replaces the need for practice. That would make sense
if companies only asked practical questions, but the reality is that most don’t. In fact,
the vast, vast majority of questions I’ve gotten over the years have little direct overlap with the
work I’ve done in the past or, most likely, the work that I would do if hired by the interviewer’s
company.&lt;/p&gt;

&lt;p&gt;The reason for this gets back to the criteria listed above; day-to-day projects rarely,
if ever, satisfy all of these. Most questions are completely synthetic and, thus, you need practice
beyond your day-to-day work to really get a handle on them.&lt;/p&gt;

&lt;h3 id=&quot;why-its-more-profitable-than-you-think&quot;&gt;Why it’s more profitable than you think&lt;/h3&gt;

&lt;p&gt;What many people don’t realize is that interview performance isn’t just a binary, “hire or no hire”
checkpoint on the way to a job offer. At many companies, even if you meet the hiring bar,
your performance is used as an input in setting your starting level and compensation. Doing an
excellent job on your coding interviews, as opposed to just a good one, may lead to a stronger
initial offer and give you more negotiating leverage as you move through your job search.&lt;/p&gt;

&lt;h2 id=&quot;enter-leetcode&quot;&gt;Enter Leetcode&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/&quot;&gt;Leetcode&lt;/a&gt; is a site designed for practicing interview-style coding
questions. It has a large pool of questions and an online code editor that allows you to write up
and submit solutions to them.&lt;/p&gt;

&lt;p&gt;Each submission is run against a set of question-specific test cases that verify both the
correctness and efficiency of the solution. If you get stuck, you can get help by looking through
official solution write-ups (available for the most popular questions) or reading the messages on
each question’s discussion board.&lt;/p&gt;

&lt;p&gt;There are a bunch of other sites in the general, “code interview prep” space. I’ve been
less satisfied with the ones that I’ve looked at, however, because their questions feel less
realistic to me; they’re often not at the right level of difficulty, or they’re simply too long to
do in a 45 minute interview. These questions may be fun to work through, but if your goal is to prep
for interviews, solving them may not be the most efficient use of time.&lt;/p&gt;

&lt;p&gt;Note that I have no official relationship with Leetcode. I just like the site and want to tell
others about it. :-)&lt;/p&gt;

&lt;h3 id=&quot;leetcode-question-difficulty&quot;&gt;Leetcode question difficulty&lt;/h3&gt;

&lt;p&gt;Leetcode classifies questions as either “easy”, “medium”, or “hard”. I’ve found that
the sweet spot for actual interviews typically begins at the middle of the “medium” tier and runs
into the bottom (i.e., easier) chunk of “hard”. “Easy” questions are fine to do as stepping stones
to the “medium” tier, but you’re less likely to see these types of questions in an actual interview.&lt;/p&gt;

&lt;p&gt;The hardest “hard” questions in Leetcode are annoying because they often require obscure
algorithmic tricks to solve efficiently. I don’t worry about these questions too much because,
in the unlikely event that I were to get a question in this tier, the interviewer would (hopefully)
provide hints. They also don’t generalize as well as the easier questions, so studying them is not
the most effective use of time.&lt;/p&gt;

&lt;h2 id=&quot;prep-strategy&quot;&gt;Prep strategy&lt;/h2&gt;

&lt;p&gt;Once you’ve gotten your Leetcode account set up, it’s time to actually start preparing.&lt;/p&gt;

&lt;h3 id=&quot;language-choice&quot;&gt;Language choice&lt;/h3&gt;

&lt;p&gt;Leetcode supports the languages that are most commonly used for interviews including C++, Java,
Javascript, Python, and Ruby. You should obviously practice in the one(s) that you intend to use.&lt;/p&gt;

&lt;p&gt;I would highly recommend choosing a single, high-level language for all of your interviews. I
personally always use Python; Ruby is also a reasonable choice. C++, on the other hand, is probably
not a great choice unless you happen to be a virtuoso in the language.&lt;/p&gt;

&lt;p&gt;There are numerous advantages to choosing a high-level language like Python:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Compact, less verbose code:&lt;/strong&gt; Assuming a fixed typing or white boarding speed, this means that
  you can construct solutions faster.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No IDE required:&lt;/strong&gt; Many interviews are still done on whiteboards or in bare-bones
  text editors, so you can’t always depend on having an IDE to help out.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rich standard libraries:&lt;/strong&gt; Python, for instance, provides binary search (in &lt;code class=&quot;highlighter-rouge&quot;&gt;bisect&lt;/code&gt;),
  permutations (in &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt;), heaps (in &lt;code class=&quot;highlighter-rouge&quot;&gt;heapq&lt;/code&gt;), and many other things that are helpful for
  solving interview questions.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of course, the company you’re interviewing at might use something else, like Java or C++. But,
that’s generally ok. In fact, in my many years of interviewing I’ve &lt;em&gt;never&lt;/em&gt; had an interviewer
complain about my use of Python or felt that it ever counted against me. The most important
thing is to deliver clean, correct code; provided you do this, the language you choose isn’t really
an issue.&lt;/p&gt;

&lt;h3 id=&quot;working-through-the-questions&quot;&gt;Working through the questions&lt;/h3&gt;

&lt;p&gt;When I’m ready to start, I pay for a premium Leetcode subscription. It’s a bit pricey (about $35 /
month as of early 2019), but I find it worth the money because it removes restrictions
in the free product including access to locked questions and the ability to sort questions by
frequency. You can still use Leetcode if you don’t pay, but you’ll have to do some offline
research to figure out which questions are the most important ones to focus on.&lt;/p&gt;

&lt;p&gt;I then sort the questions in decreasing order of frequency (only available after paying for premium)
and go through them roughly in order. I say “roughly” because I like to initially focus on the
easier questions, and then, as I get more confidence, shift to the ones in the medium-to-hard range
which, as discussed above, are more typical in actual interviews. Also, some questions are just
slight variations of ones above them in the list, so I’ll skip over these if I already feel
comfortable with them.&lt;/p&gt;

&lt;p&gt;Once I’ve decided to do a question, I’ll work on it independently for about 20 minutes. If I can’t
get a reasonable solution within this time, I’ll peek at the official solution for a few hints and
then get back to work; this is similar to how it would work in an actual interview, with the
difference being that in the real thing a person (i.e., your interviewer) would be offering
these hints.&lt;/p&gt;

&lt;p&gt;I stop working on the question when either I get all the test cases to pass or I hit the 45 minute
mark. Whether I’ve gotten a working answer or not, I read through the solution to make sure
that I have a correct understanding of the problem and the possible approaches to it. If I didn’t
get a fully working solution within 45 minutes, I’ll go back and implement one of the
approaches in the solution write-up, making sure that I fully understand what I’m writing down.&lt;/p&gt;

&lt;h3 id=&quot;solution-efficiency&quot;&gt;Solution efficiency&lt;/h3&gt;

&lt;p&gt;Many Leetcode questions can be solved in more than one way. Given a choice, I generally start with
the simplest approach. Then, if this isn’t good enough, I’ll optimize.&lt;/p&gt;

&lt;p&gt;In a real interview, this push to optimize would be done by the interviewer. In the Leetcode
case, you’ll usually know you need to optimize because a test case will time out. In the rare
event that a wildly suboptimal, naive solution passes all the test cases, you’ll notice this by
seeing that your solution is in the far right tail of the execution time histogram that Leetcode
shows at the end.&lt;/p&gt;

&lt;h3 id=&quot;consulting-external-sources&quot;&gt;Consulting external sources&lt;/h3&gt;

&lt;p&gt;Most interviewers will allow you to look up general API docs or code snippets online if you ask.
However, doing this can waste a lot of time and thus should be used sparingly in real interviews.
It’s fine to do lots of lookups early in your preparation, but by the end all of the basic tasks
in your language of choice (e.g., iterating over a hash map, reading a file, etc.) should be
committed to memory.&lt;/p&gt;

&lt;h3 id=&quot;how-much-studying-is-enough&quot;&gt;How much studying is enough?&lt;/h3&gt;

&lt;p&gt;I usually feel ready to do real interviews after I’ve solved around 100 questions. Doing more
than this has diminishing returns for me because the questions begin to look alike and my
performance doesn’t significantly improve. It takes me at least 3 weeks to get through this many
questions, assuming that I’m spending most of my weekends studying.&lt;/p&gt;

&lt;p&gt;Ultimately, the goal isn’t to hit a specific number but rather to feel comfortable with arbitrary
questions in the interview difficulty range (mid-medium to low-hard, as discussed above). You may
get to this point after only a few dozen questions or, if you’re particularly rusty, it may take
many more than 100. Likewise, the time required will also vary, from just a week or two to
6 months or more.&lt;/p&gt;

&lt;h2 id=&quot;leetcode-gaps&quot;&gt;Leetcode gaps&lt;/h2&gt;

&lt;p&gt;Leetcode has good coverage for most types of coding questions, but I have noticed some
gaps over the course of my recent job hunts. In particular, you may want to do some non-Leetcode
preparation for the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Interface design:&lt;/strong&gt; Leetcode has to provide an interface so that it can run test
  cases against your solution. In a real interview, the interface might not be provided and,
  moreover, designing it might be a big part of the question.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Writing tests:&lt;/strong&gt; Leetcode provides its own test cases, so you don’t have to write any. In
  a real interview, you may be expected to test your solution, so you should feel comfortable
  doing this in your language of choice. Using something simple like &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
  statements is fine; there’s usually no need for complicated unit testing frameworks.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Big-O analysis:&lt;/strong&gt; Some interviewers like asking about time and space efficiency after you
  write up a solution; Leetcode doesn’t explicitly test this, although the official solutions
  write-ups usually include some efficiency analysis.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Concurrency:&lt;/strong&gt; Leetcode doesn’t provide much coverage for concurrency-related problems. You may
  want to brush up on concurrency primitives in your interview language, particularly if you don’t
  use these as part of your day-to-day work.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Network and file system operations:&lt;/strong&gt; Leetcode solutions run in a sandbox, and thus aren’t
  going to be making HTTP requests or reading files from the file system. These types of questions
  aren’t super common, but some companies do like them so you may want to brush up on how to do
  them in your chosen interview language.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;popular-question-types&quot;&gt;Popular question types&lt;/h2&gt;

&lt;p&gt;During my most recent rounds of interviewing, there were some types of questions that came up
again and again. If you’re on the market, you may want to spend some time making sure you’re
extra comfortable with questions of these types.&lt;/p&gt;

&lt;h4 id=&quot;searching-andor-exploring-in-a-2d-grid&quot;&gt;Searching and/or exploring in a 2D grid&lt;/h4&gt;

&lt;p&gt;Interviewers love these questions because they hit on multiple topics at once: recursion,
dynamic programming, 2D arrays/lists, spatial reasoning, etc. They also lend themselves nicely
to follow-up challenges if you finish the question quickly and the interviewer wants to give you
more.&lt;/p&gt;

&lt;p&gt;See Leetcode &lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot;&gt;62&lt;/a&gt; and
&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot;&gt;200&lt;/a&gt; and for examples.&lt;/p&gt;

&lt;h4 id=&quot;evaluating-arithmetic-expressions&quot;&gt;Evaluating arithmetic expressions&lt;/h4&gt;

&lt;p&gt;These questions are popular because they’re easy to explain and test, but can be challenging to
implement. See Leetcode &lt;a href=&quot;https://leetcode.com/problems/basic-calculator-ii/&quot;&gt;227&lt;/a&gt; for an example.&lt;/p&gt;

&lt;h4 id=&quot;designing-and-implementing-keyvalue-stores-or-caches&quot;&gt;Designing and implementing key/value stores or caches&lt;/h4&gt;

&lt;p&gt;Caches are practical and easy to explain, but, depending on the desired performance tradeoffs,
require a good understanding of certain data structures and algorithms. Leetcode
&lt;a href=&quot;https://leetcode.com/problems/lru-cache/&quot;&gt;146&lt;/a&gt; is a classic of this type.&lt;/p&gt;

&lt;h2 id=&quot;concluding-thoughts&quot;&gt;Concluding thoughts&lt;/h2&gt;

&lt;p&gt;Preparing for coding questions makes these questions easier to solve and significantly
increases your chances of doing well in job interviews. However, no strategy is perfect, and
ultimately, no matter how smart or well-prepared you are, tech interviewing can still be a bit
of a crapshoot. If you get rejected, use the experience to better understand your weak spots
and further refine your preparation strategy.&lt;/p&gt;

&lt;p&gt;Good luck!!&lt;/p&gt;

&lt;h3 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h3&gt;

&lt;p&gt;I’d like to thank &lt;a href=&quot;https://www.linkedin.com/in/johnmishanski/&quot;&gt;John Mishanski&lt;/a&gt; for providing
feedback on early drafts of this post.&lt;/p&gt;</content><author><name></name></author><summary type="html">Having switched jobs a few times over the last few years, I've done a a lot of software engineering interviews. In my most recent job search, for instance, I did around eight phone screens followed by six on-sites.</summary></entry></feed>